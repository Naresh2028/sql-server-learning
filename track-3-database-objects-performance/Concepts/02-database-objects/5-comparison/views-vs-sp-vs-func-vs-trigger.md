# VIEWS VS STORED PROCEDURES VS FUNCTIONS VS TRIGGERS


## Which Object is suitable based on the scenario 

| Scenario ("I need to...")                                                                 | Best Tool             | Why?                                                                                                      | Key Trade-off / Note                                                                 |
|-------------------------------------------------------------------------------------------|-----------------------|-----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| Hide sensitive columns (e.g., allow interns to see Employees but not Salary).             | VIEW                  | Provides column-level security and abstraction without duplicating data.                                  | It is not faster than the original query. It's purely for security/simplicity.       |
| Execute complex logic involving multiple tables, transactions, or IF/ELSE steps.          | STORED PROCEDURE      | Can group multiple statements into one "Trip" to the database. Handles transactions (COMMIT/ROLLBACK) safely. | Harder to debug than C# code. Avoid putting business logic here if possible.         |
| Reuse a calculation inside a SELECT statement (e.g., formatting a phone number or converting currency). | SCALAR FUNCTION       | Modularizes logic so you can use it inline: `SELECT Name, fn_Format(Phone)...`.                           | Performance killer on large tables. Can prevent parallel execution.                  |
| Filter a list based on a parameter and then JOIN it to other tables (like a "Parameterized View"). | TABLE-VALUED FUNCTION | Returns a table structure that acts like a normal table but accepts inputs.                               | Generally faster than Scalar functions, but still adds complexity to the execution plan. |
| Log changes automatically whenever a specific table is modified (Audit Trail).            | AFTER TRIGGER         | "Guaranteed Execution." It fires no matter how the data was changed (App, SQL script, Admin).              | Hidden from developers. Can silently slow down every INSERT/UPDATE if the logic is heavy. |
| Prevent a specific action or redirect it (e.g., "Soft Delete" instead of real delete).    | INSTEAD OF TRIGGER    | Intercepts the command and runs your custom logic instead of the standard action.                         | Complex to maintain. If it fails, the user thinks the action happened but it didn't.  |
| Speed up searches on specific columns (e.g., WHERE Email = '...').                        | NON-CLUSTERED INDEX   | Creates a "Side Lookup List" to find rows without scanning the whole table.                               | Slows down INSERT/UPDATE operations because the index must be updated too.           |
| Sort the physical data to optimize for Ranges (BETWEEN) or Primary Key lookups.           | CLUSTERED INDEX       | The data is the index. Reading a range of dates is instant because they are physically next to each other. | Only 1 per table. Changing the key is expensive (moves physical data).               |
